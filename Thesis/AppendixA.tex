\chapter{Supplemental Information}

\section{Extra definitions and theorems}

\begin{defn} \label{ap:abeliandef}
	The \textit{free abelian group generated by a finite set}
	$$ S = \left\{s_1, s_2, \ldots, s_n \right\} $$
	is the set of all functions $ f : S \rightarrow \Z$, with the pointwise addition
		$$ (f + g)(s_i) := f(s_i) + g(s_i), \quad i = 1, 2, \ldots, n . $$
\end{defn}

\begin{defn} \label{ap:freeabeliandef}
	The \textit{free abelian group generated by a possibly infinite set} $S$ is the subgroup of $\Z^S$, consisting of all functions $f : S \rightarrow Z$ satisfying
	$$ f(s) = 0 \quad \text{for all but finitely many } s \in S. $$
\end{defn}

\section{Gray-Scott simulation code} \label{appB:gs-code}

The following code is written in the Python language. It requires the Numpy package which allows for easy and intuitive manipulation of matrices as well as Matplotlib to display the simulation. The procedure \textsc{runGS} takes four arguments: $d_u$, $d_v$, $F$, and $k$. By default, the domain size $n$ is set to 256.

\begin{Verbatim}[fontsize=\footnotesize,frame=leftline,framesep=5mm]
import numpy as np
import matplotlib.pyplot as plt

def runGS(Du, Dv, F, k):
  n = 256
  
  # create a structured n+2 by n+2 array of double precision floats
  Z = np.zeros((n+2,n+2), [('U', np.double), ('V', np.double)])
  U,V = Z['U'], Z['V']
  
  # u, v represent the concentrations of U, V
  u,v = U[1:-1,1:-1], V[1:-1,1:-1]
  
  # set initial conditions
  r = 20
  u[...] = 1.0  # set all u to 1.0
  U[n/2-r:n/2+r,n/2-r:n/2+r] = 0.50
  V[n/2-r:n/2+r,n/2-r:n/2+r] = 0.25
  
  # 'sprinkling' of random noise
  u += 0.05*np.random.random((n,n))
  v += 0.05*np.random.random((n,n))

  # set up plot
  plt.ion()

  # plot options
  size = np.array(Z.shape)
  dpi = 120.0
  figsize= size[1]/float(dpi),size[0]/float(dpi)
  fig = plt.figure(figsize=figsize, dpi=dpi, facecolor="white")
  fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)
  cmap = plt.cm.binary  # this is a greyscale colormap
  im = plt.imshow(V, interpolation='bicubic', cmap=cmap)  # show V in the plot
  plt.xticks([]), plt.yticks([])	

  # run simulation for 25000 time steps
  for i in xrange(25000):
    # discretized Laplacian matrix for u
    Lu = ( U[0:-2,1:-1] + U[2: ,1:-1] + 
       U[1:-1,0:-2] + U[1:-1,2: ] - 4*U[1:-1,1:-1] )
       
    # discretized Laplacian matrix for v
    Lv = ( V[0:-2,1:-1] + V[2: ,1:-1] + 
       V[1:-1,0:-2] + V[1:-1,2: ] - 4*V[1:-1,1:-1] )

    uvv = u*v*v  # the nonlinear term uv^2
      
    # change the concentrations in place
    u += (Du*Lu - uvv +  F   *(1-u))
    v += (Dv*Lv + uvv - (F+k)*v    )

    if i % 10 == 0:  # show only every 10 steps on the plot
      im.set_data(V)
      im.set_clim(vmin=0.0, vmax=0.4)  # set color limits
      plt.draw()
      # to save each figure
      plt.savefig('./gs/gs-%04d.png' % (i/10) ,dpi=dpi)

  plt.ioff()
  plt.close()
\end{Verbatim}